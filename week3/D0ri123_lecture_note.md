## 3주차 스터디 정리

### 1.프로세스 생성?
 - 자식은 부모의 공간을 복사함
 - 자식은 그 공간에 새로운 프로그램을 올린다.
    #### 프로세스 관련 System call
   - **fork()** : 프로세스 생성한다. 프로세스의 복사가 일어나면 부모 프로세스의 '문맥'을 복사하면서 CPU의 문맥인 PC도 복사가 된다. 이 때, PC는 pid=fork();를 가지고 있기 때문에 **복제된 자식 프로세스에서는 fork() 이후의 코드부터 실행된다.**
     1. 부모인지 자식인지 구별하기 위해서, fork()는 리턴 값을 다르게 한다. 자식 프로세스일 경우 0을 리턴하고, 부모 프로세스인 경우에는 자식 프로세스의 pid가 반환한다.
   - **exec()** : 자식은 부모를 모든 것을 복사한 것이기 때문에 fork이후의 코드는 완전히 같을 수 밖에 없다. 이 때, exec()을 통해 다른 코드를 짜면 아예 새로운 프로세스로 탈바꿈하게 된다.
   - **wait()** : 부모 프로세스에 wait()을 만나게 되면, 해당 프로세스를 잠들게 한다.(**blocked**) 이후에 자식 프로세스가 종료될 때까지 기다리게 하는 것이다. 자식 프로세스가 종료되면 다시 **ready** 상태로 돌아온다.
   - **exit()** : 호출되는 순간 프로세스가 종료된다. exit에는 자발적 종료와 비자발적 종료가 있다.
     1. 자발적 종료 
        - 프로세스의 마지막 statement에 도달하여 종료되는 경우 
        - 프로그램 코드에 exit()이 호출되어 종료되는 경우 -> 본래 수행하려던 statement를 수행하고 종료된 것이기 때문이다.
     2. 비자발적 종료
        - 외부에 의해 갑자기 프로세스가 종료하는 것을 말한다.
        - 자식 프로세스가 자원의 한계치를 초과하여 요구하는 경우
        - 자식에게 시킬 일이 모두 끝났을 경우
        - 사용자가 kill, break와 같은 명령을 입력하는 경우
        - 부모 프로세스가 종료되어야 하는 경우에 자식을 먼저 종료해야 한다.
 
### 2. 프로세스 간 협력
 - 원칙적으로 프로세스는 매우 독립적이지만 경우에 따라서는 프로세스가 협력을 해야만 효율적으로 실행되는 경우도 있다. 즉, 프로세스 간 협력 메커니즘이 존재한다.
 - 프로세스 간 협력 메커니즘을 IPC(Interprocess Communication)이라 한다. 크게 두 가지 방법이 존재한다.
   1. Message passing : 커널을 통해 메시지를 전달하는 방법이다.
      - 프로세스 사이에 공유 변수를 일절 사용하지 않고 통신하는 시스템이다. direct와 indirect Communication이 있다.
        ![image](https://user-images.githubusercontent.com/94590894/188995561-9d2edce9-3585-4877-b1e4-2d9ed63ebfc1.png)
      - Direct Communication : 통신하려는 프로세스의 이름을 명시적으로 표시한다.
      - Indirect Communication : mailbox(또는 port)를 통해 메시지를 간접적으로 전달한다.
      - Direct와 Indirect는 둘 다 커널을 통해서 메시지를 전달하지만, 받는 프로세스를 명시하느냐 하지 않느냐에 따라 나뉘어진다.
   2. shared memory : 주소 공간을 공유하는 방법이다. 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있다.
      - 물리적인 메모리에 매핑할 때 일부영역은 공유되도록 매핑하는 것이 shared memory이다.
      - 프로세스 생성 시 기본적으로 주소 공간은 서로 겹치는 것이 아니다. 그렇기 때문에 커널에게 shared memory를 사용하겠다는 system call을 해줘야 한다.
        ![image](https://user-images.githubusercontent.com/94590894/188995800-be65aebb-233a-4ff3-9d68-af8c70ce4857.png)

 - 스레드들은 프로세스 여러개가 아닌 한 프로세스 내의 CPU 수행 단위가 여러개이다. 프로세스 간 협력으로 보기는 어렵지만, 스레드 간에는 주소 공간을 공유하므로 협력이 가능하다.

### 3. CPU scheduling
 - 프로세스는 CPU burst와 I/O burst가 서로 바꿔가면서 프로그램을 실행하는 것이다.
   - CPU burst : CPU 명령을 실행하는 것을 말한다.(주로 계산)
   - I/O burst : I/O를 요청한 다음 기다리는 시간을 말한다.(주로 입력)
   - 즉, 프로세스는 명령어를 수행하다가 I/O를 기다렸다가 해결이 되면 다시 CPU에서 남은 명령어를 수행하는 작업을 계속 반복한다.
   - 프로세스는 크게 CPU bound process와 I/O bound process로 크게 두 종류로 나눠볼 수 있다.
   - CPU bound process는 CPU burst가 큰 프로세스, I/O bound process는 I/O burst가 큰 프로세스를 말한다.
   ![image](https://user-images.githubusercontent.com/94590894/188996997-8f6251c0-2279-478a-8706-659145945df2.png)
   - CPU bound process는 수학 처리 작업이 주를 이루기 때문에 일상에서는 잘 사용되지 않는다. 기상청 혹은 과학 계산용 프로그램에 쓰인다(시뮬레이션, 일기예보 등 계속 몇시간동안 계산을 하며 향후 미래 예측하는 작업)
   - **위의 그래프를 통해,**
     - 우리가 사용하는 프로그램들의 CPU burst 시간을 측정했을 때 주로 대부분이 짧다는 것을 알 수 있다.
     - 또한 여러 종류의 프로세스가 섞여 있기 때문에 ***CPU 스케줄링***이 필요하다.(적절한 response 제공과 시스템 자원을 골고루 효율적으로 사용해야 한다)
     - CPU 스케줄링이란 준비 상태에 있는 프로세스 중에서 어떤 프로세스에게 CPU를 할당할 것인지 결정함에 따라 시스템의 효율이 달라진다.

 - CPU scheduler(중기 스케줄링)와 Dispatcher
   - CPU scheduler는 ready 상태의 프로세스 중에서 CPU를 줄 프로세스를 고른다.
   - Dispatcher는 CPU scheduler에 의해 선택된 프로세스에게 CPU 제어권을 넘긴다. 이 과정을 문맥교환이라고 한다.
   - CPU 스케줄링이 필요한 경우는 프로세스에게 다음과 같은 상태 변화가 있는 경우이다.
     1. Running -> Blocked(ex. I/O 요청하는 시스템 콜)
     2. Running -> Ready(ex. 할당시간만료로 timer interrupt)
     3. Blocked -> Ready(ex. I/O 완료 후 인터럽트)
     4. Terminate
     - 1,4에서의 스케줄링은 nonpreemptive(=강제로 빼앗기지 않고 자진 반납)
     - 2,3에서의 스케줄링은 preemptive(강제로 빼앗음)
 
 - **비선점(nonpreemptive) vs 선점(preemptive) 방식**
   - 비선점 스케줄링 방식은 CPU를 할당 받은 후에는 종료되기 전까지 독점한다.
   - 선점 스케줄링 방식은 CPU를 할당 받고 실행 중, 다른 프로세스로부터 CPU 사용의 요청을 받으면 비켜준다. 빈번한 문맥교환은 오버헤드가 발생할 위험이 있다.
 
 - CPU 스케줄링 성능 척도(시스템 측면과 프로그램 측면에서 볼 수 있다)
   - 시스템 측면
     1. CPU utilization(이용률) : 단위 시간 당 CPU가 사용되는 시간. 가능한 바쁘게 유지하게 하는 것이 잘 쓰는 것이다.(최대로 사용해줘야 한다)
     2. throughput(처리율) : 단위 시간당 완료된 프로세스의 개수. 주어진 시간동안 몇 개의 작업을 완료했는가에 대한 지표이다.
   - 프로그램 측면
     1. Turnaround Time(반환시간) : 하나의 프로세스를 마무리하는 데 걸리는 시간이다. 프로세스가 가능하면 빨리 CPU를 쓰러 들어와서 다 쓰고 나갈때까지 걸린 시간을 말한다. 
     2. waiting Time : 프로세스가 준비상태에서 처리되기를 기다리는 시간이다(ready queue에 있는 시간). CPU를 쓰기까지 순수하게 기다린 시간이다.
     3. response Time : CPU를 처음으로 얻기까지 걸린 시간이다.
 
 - ***FCFS 스케줄링(First Come, First Service 선입선출), Nonpreemptive***
   - 프로세스들이 ready queue에 도착한 순서에 따라 차례로 CPU를 할당하는 기법이다.
   - 공평성은 유지되나, 짧은 작업이나 중요한 작업이 늦게 도착하면 작업이 지연된다는 단점이 발생한다.
   - 작업 완료시간을 예측하기 쉽다.
   - convoy effect : 먼저 도착한 프로세스가 CPU burst가 길면, 다음 프로세스가 긴 시간을 기다려야 하는데 이를 convoy effect라고 말한다. 이 효과가 발생할 경우 CPU와 장치 이용률이 낮아진다.
 
 - ***SJF 스케줄링(Shortest Job First, 단기작업 우선), Nonpreemptive***
   - ready queue에서 기다리고 있는 프로세스 중에서, 실행시간이 가장 짧은 것부터 먼저 실행하는 방식이다.
   - 짧은 시간들이 앞에서 먼저 실행되고 빠져나가기 때문에 전체 작업들의 평균 대기시간이 가장 짧다.
   - 그러나, 실행시간이 긴 작업은 앞에서 짧은 작업들이 계속 추가될 경우에 무한 연기될 수도 있다.
   - 비선점 방식은 SJF이고, 선점 방식으로는 SRTF(Shortest-Remainin-Time-First)가 있다. 
     - SRTF? 현재 수행중인 프로세스의 남은 burst time보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU를 빼앗긴다.
 
 - ***Priority(우선순위) 스케줄링***
   - ready queue에 프로세스가 도착하면, 도착한 프로세스의 우선순위와 현재 실행 중인 프로세스의 우선순위를 비교하여 우선순위가 가장 높은 프로세스에 CPU를 할당하는 방식이다.
   - 우선순위가 동일하면 FCFS방식으로 CPU를 할당한다.
   - 우선순위가 높은 프로세스를 가장 작은 숫자로 표현하는 것이 일반적이다.
   - 가장 낮은 우선순위를 부여받은 프로세스는 무한연기에 빠져 결국 실행하지 못하는 기아상태(starvation)에 빠질 수 있다.
   - starvation의 해결책으로 aging기법이 있는데, aging은 매 분마다 대기 중인 프로세스의 우선순위를 1씩 증가시킨다. 이렇게 함으로써, 초기에 우선순위가 낮았던 프로세스가 대기중이면 CPU를 할당받은 프로세스보다 우선순위가 높아지는 시점이 발생하여 starvation을 해결할 수 있다.
   
   ![image](https://user-images.githubusercontent.com/94590894/189002320-7891e9e7-798d-477e-b7e1-59a2e88327c2.png)

 - ***RR 스케줄링(Round Robin)***
   - 각 프로세스는 동일한 크기의 할당시간(time quantum)을 가진다. 할당시간이 지나면 프로세스는 CPU를 뺏기고, 다시 ready queue의 제일 뒤에 가서 다시 줄을 선다.
   - 할당 시간이 지나면 CPU를 뺏기기 때문에, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.
   - 할당시간 q가 너무 크면, FCFS와 유사해진다. q가 너무 작으면, context switch 오버헤드가 커진다.
 
 - ***다단계 큐 스케줄링***
   - 우선순위마다 여러 개의 ready queue를 형성한다.
   - 기억장치 요구량, 프로세스 유형별 우선순위 등을 구분하여 관리하기 위한 다단계 큐를 지니고 있으며, 큐들은 각각 자체적인 스케줄링 정책을 가지고 있다.
   - queue들 간의 프로세스 이동이 불가하기 때문에 스케줄링 부담이 적지만 유연성이 떨어진다.
   - 우선순위가 낮은 프로세스가 오랫동안 CPU 할당을 기다리는 기아 현상이 발생할 수도 있다.
   - **사용자와 상호작용하며 작동하는 프로세스는 요구하는 응답시간이 짧아야 한다. 이러한 이유로 앞단의 프로세스들(foreground process)은 백그라운드에서 조용히 돌아가는 프로세스들보다 더 높은 우선순위를 가진다. 그리고 foreground와 background 프로세스 큐에서는 다른 알고리즘이 적용되어야 더 효율적인 성능을 끌어낼 수 있다.**
   - background에서는 보통 FCFS 알고리즘이 작동하고, foreground에서는 RR알고리즘이 작동한다. 즉, queue를 여러개로 분리해놓고 queue별로 스케줄링 알고리즘을 지정하는 것이다.
   - 프로세스의 성격에 따라 아래의 그림처럼, queue에 우선순위를 부여한다. 
   
   ![image](https://user-images.githubusercontent.com/94590894/189006003-e8342988-2188-4793-9a35-fe5670c5e730.png)

 - ***다단계 피드백 큐 스케줄링***
   - 사용자와 interactive하지 않은 background의 프로세스는 CPU burst가 매우 크다는 특징을 이용한 알고리즘이다.
   - 제일 초반에 나온 queue의 time quantum을 설정하고 이를 다 채우지 못한 프로세스는 그대로 빠져나가고, time quantum을 다 채운 프로세스는 밑의 레벨에 있는 queue로 들어간다. 밑의 queue는 time quantum의 크기를 위의 큐보다 두배로 돌린다.
   - 마지막 큐는 FCFS로 처리하는 것이 일반적이다.
   - 한 큐의 time quantum을 다 채웠다는 것은 CPU burst process일 가능성이 높다. 계속 밑으로 내려갈수록 CPU bound process라는 확신을 가지고 아예 밑으로 내려간다. 이는 대화형으로 동작하는 것이 아니므로, context switching을 안하고 계속 쭉 수행시켜주면 되므로 FCFS를 채택하는 것이다.
   - 즉, 다음 단계로 넘어갈수록 CPU burst가 크다는 거니깐 우선순위가 점점 낮아진다고 생각하는 것이다. 
   - 우선순위가 높은 프로세스만 들어오면 낮은 프로세스는 무한 지연되는 starvation문제가 발생한다. 이런 경우 aging 방식을 도입하여 해결할 수 있다. -> 낮은 우선순위 큐에서 너무 오래 기다리는 프로세스들은 높은 우선순위 큐에 다시 갖다놓는다.
   - 프로세스의 큐 이동이 유연하다. turnaround 평균 시간, response time을 줄일 수 있다.