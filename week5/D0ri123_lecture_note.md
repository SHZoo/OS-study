## Semaphore와 mutex의 개념 
 ### 1. Semaphore란?
 - 공유된 자원 속 하나의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한해둬야 하는데 이를 위해 고안된 것이 세마포어이다.
 - **두 개의 atomic(쪼갤 수 없는)원자적 함수로 조작되는 정수 변수로서, 멀티 프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법으로 사용된다.**
 - 세마포어는 운영체제 또는 커널의 한 지정된 저장장치 내 값으로서, 각 프로세스는 이를 확인하고 변경할 수 있다. 확인되는 세마포어의 값에 따라, 즉시 사용 가능 여부를 판단할 수 있다.
 - 세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 기다리도록 해야한다. 
 - **리소스의 상태를 나타내는 간단한 카운터**
 
 ### 1-1. Semaphore의 함수호출은?
 - 세마포어 S는 정수값을 가지는 변수이며, P(wait)와 V(signal)라는 명령에 의해서만 접근 가능하다. 
   - P는 자원을 획득하는 과정이고, V는 자원을 반납하는 과정이다. P는 critical section에 들어가기 전에 수행되고, V는 나올 때 수행된다.
 - 세마포어에는 계수 세마포어(counting semaphore)와 이진 세마포어(binary semaphore)가 있다.
   - **계수 세마포어**는 초기값이 사용 가능한 자원의 수로 정해지며, 사용이 될때마다 1씩 값이 줄어든다.(Mutex라고도 할 수 있다)
   - **이진 세마포어**는 lock처럼 0과 1로 구성이 되어 있지만, lock과는 달리 초기값이 1로 설정되어 있다.

 ### 2. Mutex란?(=binary semaphore)
 - Mutual Exclusion으로 상호배제라고도 한다. critical section을 가진 쓰레드들의 러닝타임이 겹치지 않게 각각 단독으로 실행되게 하는 기술이다. 공유 자원에 대한 접근을 조율하기 위해 locking과 unlocking을 사용한다.
 - Mutex 객체를 두 쓰레드가 동시에 사용할 수 없다.
 - 한 프로세스에 의해 소유될 수 있는 key를 기반으로 한 상호배제 기법이다. 즉, key에 해당하는 어떤 객체가 있으며 이 객체를 소유한 스레드/프로세스만이 공유자원에 접근할 수 있다.

 ### 3. Semaphore의 정리
 - 기존에 배운 방식의 공통점은 커널 내의 루프(while문)를 활용해서 임계구역에 lock을 걸면서 접근을 제한한다. 이는 임계구역에 들어갈 때까지 무한 루프를 돌기 때문에(spin lock), 타임슬라이스를 사용하여 낭비 문제가 발생한다.
 - 세마포어는 이를 보완하기 위해 고안된 개념이며, critical section에 진입하기 어려우면 자발적으로 대기(block)상태에 들어가는 것이다. 임계구역을 떠나는 프로세스가 대기 상태에 있는 프로세스를 준비 상태로 깨워준다.
 - 즉 block/wakeup 알고리즘이 된다. 이로써 타임슬라이스의 낭비를 줄일 수 있다.
 - 구성은 1-1에서 언급한 함수와 덧붙여 자원 현황을 나타내는 정수값(value, 초기값은 자원의 개수), 프로세스 대기큐(세마포어 대기큐)로 이루어져 있다.
 - 세마포어 개념과 별개로 무한루프를 도는 것이 무조건 나쁜 것은 아니다. 상호배제 관계에 있는 임계구역의 계산량이 현저히 작기 때문에 spinlock이 세마포어보다 문맥교환의 오버헤드를 줄일 수 있다.

 ### 4. Semaphore와 Mutex의 차이
 - Mutex
  
![image](https://user-images.githubusercontent.com/94590894/192129919-800d6f10-3fab-4823-9491-bd70ae9f52a5.png)
 - Semaphore
  
![image](https://user-images.githubusercontent.com/94590894/192129948-0cb8a7b7-155d-45a2-a13b-7c614e828d78.png)

 - Mutex는 동기화 대상이 1개일 때 사용가능하고, Semaphore는 동기화 대상이 1개 이상일 때 사용가능하다.
 - 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.
 - 뮤텍스는 자원 소유 가능 + 책임을 가지는 반면, 세마포어는 자원 소유가 불가하다.

----------
## Classical Problems of Synchronization
#### 1. Bounded-Buffer Problem(Producer-Consumer Problem)
#### 2. Readers and Writer Problem
#### 3. Dining-Philosophers Problem




-----------
## Deadlock
 ### 1. Deadlock이란? 
 - 교착상태라고도 하며, 두 개 이상의 작업이 서로 상대방의 작업을 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태를 가리킨다.
 - 주로 멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 경쟁하는 상황이 발생한다. 이로 인해 무한대기가 나타난다.

 ### 1-1. Deadlock 발생의 4가지 조건
 : 한 가지라도 만족하지 않으면 Deadlock은 발생하지 않는다. 그렇다고 해서 4가지 조건이 모두 완전 독립적인 것은 아니다.
 - Mutual exclusion(상호 배제) : 자원은 한번에 한 프로세스에서만 사용할 수 있다.
 - No preemption(비선점) : 다른 프로세스에 할당된 자원은 사용이 끝날때까지 강제로 뺏을 수 없다.
 - Hold and wait(보유대기) : 자원을 이미 점유하고 있는 프로세스가 다른 자원을 기다릴 때 보유한 자원을 놓지않고, 계속 가지고 있는다.
 - Circular wait(순환대기) : 자원을 기다리는 프로세스 간에 사이클이 형성되어야 한다. 
   - **사이클?** 프로세스 P0, P1,...이 있을 때, P0는 P1이 가진 자원을 기다리고, P1은 P2가 가진 자원을 기다리는 사이클

 ### 2. 자원할당 그래프
 - 교착상태를 가시화하여 나타낼 수 있는 그래프이다. 
 - Vertex로 Process와 Resource를 나타낼 수 있다.
 - Edge로 (P->R)프로세스가 자원을 요청, (R->P)자원이 프로세스에 속해있다는 걸 의미한다.

 > ![image](https://user-images.githubusercontent.com/94590894/192500227-33bffcf3-adb4-4db0-857c-667dfb94f70c.png)
 - 위의 그림에서 알 수 있는 사실은,
   - R1과 R3의 인스턴스(instance, 사용 가능한 자원의 개수)는 각각 1개씩이고, R2와 R4의 인스턴스는 각각 2개, 3개이다.
   - P1은 R2를 가지고 있고, R1을 요청하고 있다.
   - P2는 R1과 R2를 가지고 있고, R3를 요청하고 있다.
   - P3는 R3를 가지고 있다.
   - P3가 작업을 완료하고 R3를 반납하면 P2는 작업을 완료할 수 있게 되고, 이어서 P1도 완료할 수 있게 되므로 교착상태가 아니다.
   - **위의 경우는 cycle이 없는 경우이다.**

 
 ### 2-1. 자원할당 그래프의 종류
 - **자원의 개수가 1개인 경우 :**
   - 사이클이 없다면, deadlock도 없다.
   - 사이클이 있다면, deadlock이 있다.
 - **각 자원의 개수가 1개 이상인 경우 :** 
   - 사이클이 없다면, deadlock도 없다.
   - 사이클이 있다면, deadlock의 가능성이 있다.

  **<사이클이 있고, deadlock인 경우>**
>![image](https://user-images.githubusercontent.com/94590894/192504396-90920f7f-8e41-4094-8933-7583b8a610c1.png)
 - cycle1 : P1 -> R1 -> P2 -> R3 -> P3 -> R2 -> P1
 - cycle2 : P2 -> R3 -> P3 -> R2 -> P2
 - P3가 작업을 완료하려면, R2가 필요한데 P1과 P2도 연쇄적으로 서로의 자원이 필요한 상황이기 때문에 R2를 놓을 수 없다. 
 
 **<사이클이 있고, deadlock이 아닌 경우>**
>![image](https://user-images.githubusercontent.com/94590894/192506440-0db69044-b1d1-4f7d-8007-de42e2c14655.png)
 - 사이클을 'P1 -> R1 -> P3 -> R2 -> P1'이라고 생각할 수 있지만, 현재 R1과 R2는 인스턴스가 1개 이상씩 가지고 있다. 다른 프로세스에서 작업을 완료하고 반납하면 언젠가는 완료될 수 있다.

 ### 3. Deadlock의 처리방법
   **1. Deadlock Prevention(교착상태 예방)**
   - 자원 할당 시 deadlock의 4가지 필요조건 중 어느 하나가 만족되지 않도록 하는 방법이다.

   **2. Deadlock Avoidance(교착상태 회피)**
   - 자원 요청에 대한 부가적인 정보를 이요해서 deadlock의 가능성이 없는 경우에만 자원을 할당하는 방법이다.
   - deadlock의 가능성이 조금이라도 있으면 원천차단한다.

   **3. Deadlock Detection and recovery(교착상태 탐지&회복)**
   - Deadlock 발생은 허용하되 그에 대한 detection 루틴을 둬서 deadlock 발견 시에 recover한다.

   **4. Deadlock Ignorance(교착상태 무시)**
   - Deadlock을 시스템이 책임지지 않는다. 현재 대부분의 OS가 채택하는 방법이다.

 ### 3-1. Deadlock Prevention
 - 4가지 조건(상호 배제, 비선점, 보유대기, 순환대기) 중 하나를 부정하면 되는 방법이다.
 - 그러나 부정했을 경우의 결과를 통해 이는 **Utilization 저하, throughput 감소, starvation 문제 발생** 이라는 결과를 낳는다.
 - 비효율적인 방안이다.
 
 ### 3-2. Deadlock Avoidance 
 - 각 프로세스에 자원을 할당하여 deadlock이 발생하지 않는 상태를 **안전 상태**라고 한다.
 - 이에 반해, 교착상태가 발생할 수 있는 상태를 **불안정 상태**라고 한다.
 - deadlock avoidance는 불안정 상태에 들어가지 않는 것을 보장하는 방법이다.
 - 2가지의 avoidance 알고리즘이 있다.
   - 각 자원의 인스턴스 개수가 1개씩일 때에는, Resource Allocation Graph 알고리즘을 사용한다.
   - 각 자원의 인스턴스 개수가 2개 이상일 때에는, Banker's 알고리즘을 사용한다.
   #### Resource Allocation Graph 알고리즘
   - 앞서 배운 자원할당 그래프에서 edge에 점선이 추가 된 것이다. 점선 표시는 프로세스가 자원을 미래에 요청할 수도 있음을 뜻한다.
   - 프로세스가 해당 자원을 요청하는 경우 기존처럼 실선으로 바뀌고, 반납하면 다시 점선으로 바뀐다.
   - 실선으로 변경할 때 cycle이 생기지 않는 경우에만 요청자원을 할당해준다.
   - Cycle 생성 여부 조사시, 프로세스 수가 n일 때 O(n^2) 시간이 걸린다.
   >![image](https://user-images.githubusercontent.com/94590894/192511478-f680d1b2-3026-48ac-b2c4-cfc1153348e8.png)
     
   #### Banker's 알고리즘
   - 새로운 프로세스가 시스템에 들어가면 프로세스가 요구하는 자원의 최대량을 파악한다.
   - 최대량은 기존 시스템에 있는 자원수를 초과할 수 없다.
   - 프로세스가 자원을 요구하면, 시스템은 요청한 자원을 할당한 후에도 시스템이 안전상태인지를 판단하고 할당한다.
   - 안전상태가 되지 못한다면 필요한 자원이 다른 프로세스에 의해 반납될 때까지 기다리도록 한다.
   >![image](https://user-images.githubusercontent.com/94590894/192512363-c571deef-a535-4e10-b238-18db099cae7e.png)
   
 ### 3-3. Deadlock Detection 
      교착상태 예방(Prevention)은 실제로 구현하기가 어렵고, 교착상태 회피(Avoidance)는 구현이 가능하지만 자원 낭비의 단점이 있다. 
      가장 현실적인 것은 교착상태 탐지를 통한 발견이다.
 - 자원의 인스턴스 개수가 각자 1개인 경우에는 정기적인 사이클 검사로도 충분하다.
 - 자원의 인스턴스 개수가 여러개인 경우에는 banker's 알고리즘으로 검사한다.
 - 기본적으로 deadlock이 발생하는 시점은 **새로운 자원을 요청했을 때**이므로 요청을 들어줄 때마다 탐지 알고리즘을 돌리는 것이 이상적이다.
 - 그래야 어떤 요청에 의해 deadlock이 발생했는지도 알 수 있다. 그러나 매 요청마다 돌리는 것은 비효율적이다.
 - deadlock에 빠진 작업은 CPU를 사용하지 않는다는 점을 이용하여 **CPU 이용률이 40%이하일 때** 알고리즘을 실행하면 된다.
 - 그러나 누가 교착상태를 일으켰는지는 알 수 없게 된다. 이를 위해 deadlock 회복 방법이 실행된다.

 ### 3-4. Deadlock Recovery
      탐지 알고리즘을 통해 교착상태를 발견했다면, 다음 두가지 방법 중 하나를 선택하여 deadlock을 끊어낼 수 있다.
      1. 교착상태에 얽힌 프로세스를 중지시킨다.
      2. 얽힌 프로세스의 자원을 뺏는다(선점한다)
 - 프로세스 중지의 경우에도 2가지 선택지가 있다. (1)얽힌 모든 프로세스를 중지, (2)교착상태가 없어질 때까지 하나씩 중지
   (1) 모든 프로세스를 중지시키면 확실히 deadlock을 없앨 수 있지만, 지금까지의 연산 결과를 모두 잃기 때문에 비용이 크게 든다.
   (2) 하나씩 중지시키면, 매 작업을 중지시킬때마다 교착상태에 있는지 검사해야하므로, 오버헤드가 커지게 된다.
 - 교착상태가 없어질 때까지, 얽힌 프로세스에서 무작위로 하나를 선택하여 자원을 지속적으로 빼앗는다.
   - 특정 작업이 계속해서 자원이 뺏길 수 있기 때문에 기아현상을 염두해둬야 한다. 
   - 이 현상을 막기 위해서는 우선 순위에 희생횟수를 포함시키면 된다.
 