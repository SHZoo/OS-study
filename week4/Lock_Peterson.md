 - 소프트웨어적 방법으로는 **Peterson알고리즘**이 있고, 하드웨어적 방법으로는 **Test and Set**이 있다.
 - Peterson알고리즘과 Test and Set을 배우기 전에 **Lock**에 대해서 알아야 한다.
 - 기존 동기화를 해결하는 방법으로는 원래 Lock이 있었고 여기서도 문제점이 발생하여 Peterson알고리즘과 Test and Set이 나온 것이다.
-----------------
 ### Lock
    Lcok : 말그대로 걸어잠구는 행위를 의미한다. 내가 자원을 사용하고 있는 동안 lock을 걸어 나 말고는 아무도 못들어오게 하는 방식이다.
 - race condition을 유발하는 critical section에 들어갈 때에는 lock을 걸고, 나올 때는 lock을 풀어주는 방식이다.
 - 스레드A와 스레드B가 있다고 가정하자
   1. 스레드A가 먼저 수행되어 cs(Critical section)에 들어갈 때 lock을 건다.
   2. 스레드A가 cs내의 코드를 수행하고 있을 때, timer interrupt가 걸려온다고 가정하자.
   3. 스레드A는 더이상 실행되지 못하고, 스레드B가 실행된다.
   4. 스레드B가 cs로 진입하려 하는데 이미 스레드A가 lock을 걸어뒀기 때문에 실행되지 못하고, 스케줄링에 의해서 다시 스레드B가 실행된다.
      1. 이때 스레드B는 lock이 걸린 상태에 들어와서 코드를 실행하지 못하고 unlock이 될때까지 무한루프에 빠진다. 
      2. 무한루프에서 계속 돈다고 하여 spinlock 또는 busy-waits라고 한다.
   5. 스레드B는 cs를 끝까지 실행하고, 마지막으로 나갈때 unlock을 한다. 그렇게 되면 스레드A가 cs에 들어갈 수 있게 된다.
 

### Lock의 한계점
   - lock의 방식은 어떤 상황에서 문제점이 발생할 수 있다.
   - 예를 들어서, 스레드A가 lock을 걸기 직전에 interrupt가 걸린다면, 스케줄링에 의해서 스레드B가 실행된다.
   - 스레드A가 lock을 걸어주지 못했으므로, 스레드B가 lock을 걸 수 있게 된다. 
   - 이는 즉 cs에서 동시접근의 상황이 발생한 것이다.

### 한계점에 대한 해결책
   1. 소프트웨어 알고리즘(대표적으로 Peterson알고리즘이 있다)
   2. 더 이상 쪼개지지 않는(atomic) 하드웨어 명령어
   3. 인터럽트를 disable하고 enable하게 한다.

-------

### Peterson 알고리즘
 - 현재에는 이보다 더 좋은 방법이 많이 나와서 사용되지는 않지만, 소프트웨어적으로 어떻게 동기화 문제를 예방하는지에 대한 좋은 인사이트를 줄 수 있는 알고리즘이기 때문에 공부해야 한다.
 - 요약하기 전에 P0프로세스와 P1프로세스가 있지만, 일반화를 위하여 Pi와 Pj프로세스로 표시한다.
 - 피터슨 알고리즘은 boolean flag[2]와 int형 turn, 2개의 변수를 사용한다.
 - **flag** : cs(Critical section)에 진입하려는 것을 나타내는 변수, 진입의사를 표시하는 것이다.
 - **turn** : 어느 프로세스가 cs에 진입할 것인지, 어느 프로세스의 차례인지 명시해준다.
 - 피터슨 알고리즘은 들어가고 싶어하는 프로세스(flag[i] = true)가 있는데 **들어가기 전에 먼저 다른 프로세스에게 진입 기회를 양보한다는 특징이 있다.**
 
 ![image](https://user-images.githubusercontent.com/94590894/190838962-08f35813-1b7b-48a1-85c2-d457bc8c9f29.png)
  #
    위의 그림은 Pi의 프로세스에서 피터슨 알고리즘이 적용되는 코드이다. 
    [1] 먼저, flag[i]를 true로 바꿔준다(들어가고 싶다는 의사를 표현한다)
    [2] 그리고 상대 프로세스(혹은 스레드)의 차례로 바꾼다(turn=j). 만약 상대 프로세스의 차례로 바꿨을 때, 상대 프로세스도 cs에 들어가고 싶다고 한다면
    상대 프로세스가 들어가도록 양보해준다. 
    [3] 그동안 Pi는 busy-waits상태가 되는 것이다. 상대 프로세스가 cs를 나오면 Pi프로세스가 들어가고 그다음 나올 때 flag[i]를 false로 바꿔준다.

 - 피터슨 알고리즘은 프로그램적 해결법의 충족조건을 모두 만족할 수 있다.
   - cs에 접근하기 위해서는 다른 프로세스가 기다려서는 안되고, 내 차례여야 한다. (상호 배제 조건 만족)
   - Pi의 프로세스에서 'while (flag[j] && turn==j)'라는 코드를 통하여, 내 순서가 아니더라도 남들이 안쓰면(flag[j]=false), 쓸 수 있다. (진행 조건 만족)
   - Pi는 while코드 진행동안 turn의 값을 변화시키지 않는다. 오로지 j에 의해서만 바뀐다. 즉 남에 의해서 cs에 들어갈 수 있다. 이로 인해 한 프로세스가 계속해서 사용할 수 없게 제한을 둘 수 있다.(유한 대기 조건 만족)
